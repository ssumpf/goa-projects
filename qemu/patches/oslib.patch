diff --git a/qemu/util/oslib-posix.c b/qemu/util/oslib-posix.c
index 2d6dc7f..78fa336 100644
--- a/qemu/util/oslib-posix.c
+++ b/qemu/util/oslib-posix.c
@@ -57,6 +57,10 @@
 #include <lwp.h>
 #endif
 
+#ifdef __GENODE__
+#include <genode_secondary_stack.h>
+#endif
+
 #include "qemu/mmap-alloc.h"
 
 #define MAX_MEM_PREALLOC_THREAD_COUNT 16
@@ -97,10 +101,31 @@ int qemu_get_thread_id(void)
 #if defined(__linux__)
     return syscall(SYS_gettid);
 #elif defined(__FreeBSD__)
+#ifdef __GENODE__
+
+    /* on Genode stacks are max 1M - XXX potential to break unnoticed */
+    int thread_ids_base = genode_stack_area_virtual_base() /
+                          genode_stack_virtual_size();
+
+
+    int thread_id_base = ((unsigned long)&thread_ids_base) /
+                          genode_stack_virtual_size();
+
+
+    if (thread_id_base < thread_ids_base || thread_id_base - thread_ids_base >= 256) {
+        perror("qemu_get_thread_id calculation failed");
+        exit(1);
+    }
+
+    printf("%s %d\n", __func__, thread_id_base - thread_ids_base);
+
+    return thread_id_base - thread_ids_base;
+#else
     /* thread id is up to INT_MAX */
     long tid;
     thr_self(&tid);
     return (int)tid;
+#endif
 #elif defined(__NetBSD__)
     return _lwp_self();
 #elif defined(__OpenBSD__)
@@ -635,6 +660,10 @@ char *qemu_get_pid_name(pid_t pid)
     char *name = NULL;
 
 #if defined(__FreeBSD__)
+#if 1
+    perror("qemu_get_pid_name not implemented");
+    exit(1);
+#else
     /* BSDs don't have /proc, but they provide a nice substitute */
     struct kinfo_proc *proc = kinfo_getproc(pid);
 
@@ -642,6 +671,7 @@ char *qemu_get_pid_name(pid_t pid)
 //        name = g_strdup(proc->ki_comm);
         free(proc);
     }
+#endif
 #else
     /* Assume a system with reasonable procfs */
     char *pid_path;
@@ -655,7 +685,6 @@ char *qemu_get_pid_name(pid_t pid)
     return name;
 }
 
-
 void *qemu_alloc_stack(size_t *sz)
 {
     void *ptr;
@@ -664,6 +693,9 @@ void *qemu_alloc_stack(size_t *sz)
     void *ptr2;
 #endif
     size_t pagesz = qemu_real_host_page_size();
+
+    printf("%s pagesz=%lu sz=%lu\n", __func__, pagesz, *sz);
+
 #ifdef _SC_THREAD_STACK_MIN
     /* avoid stacks smaller than _SC_THREAD_STACK_MIN */
     long min_stack_sz = sysconf(_SC_THREAD_STACK_MIN);
@@ -674,6 +706,26 @@ void *qemu_alloc_stack(size_t *sz)
     /* allocate one extra page for the guard page */
     *sz += pagesz;
 
+#ifdef __GENODE__  /* Genode stack allocation style via using base ABI directly */
+    {
+        size_t stack_size = MIN(genode_stack_virtual_size() - 3 * 4096,
+                                *sz);
+
+        ptr = genode_allocate_secondary_stack("ucontext", stack_size);
+        pthread_t * gt_pthread = malloc(sizeof(pthread_t));
+
+        int res = genode_pthread_create_from_thread(gt_pthread, ptr);
+        if (res)
+            printf("%s: secondary pthread stack res=%d failed\n", __func__, res);
+
+        uintptr_t align_ptr = ((uintptr_t)ptr) & ~0xffful;
+        ptr = (void *)(align_ptr - stack_size + (align_ptr ? 4096 : 0));
+        *sz = stack_size - (align_ptr ? 4096 : 0);
+    }
+
+    return ptr;
+#endif
+
     flags = MAP_PRIVATE | MAP_ANONYMOUS;
 #if defined(MAP_STACK) && defined(__OpenBSD__)
     /* Only enable MAP_STACK on OpenBSD. Other OS's such as

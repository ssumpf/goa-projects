diff --git a/src/lib/mesa/src/gallium/drivers/iris/iris_bufmgr.c b/src/lib/mesa/src/gallium/drivers/iris/iris_bufmgr.c
index 98483f3..68f0585 100644
--- a/src/lib/mesa/src/gallium/drivers/iris/iris_bufmgr.c
+++ b/src/lib/mesa/src/gallium/drivers/iris/iris_bufmgr.c
@@ -566,6 +566,7 @@ iris_bo_busy_syncobj(struct iris_bo *bo)
    return iris_bo_wait_syncobj(bo, 0) == -ETIME;
 }
 
+static bool _genode_bo_busy(struct iris_bo *bo);
 bool
 iris_bo_busy(struct iris_bo *bo)
 {
@@ -980,6 +981,50 @@ alloc_bo_from_slabs(struct iris_bufmgr *bufmgr,
    return bo;
 }
 
+
+bool drm_genode_busy(unsigned handle);
+
+/*
+ * Special implementation for 'alloc_bo_from_cache', because the function only
+ * needs to know if the bo in cache is used by a batch buffer. Since
+ * 'iris_bo_busy' uses 'iris_bo_wait_syncobj'  which leads to more required
+ * features which we don't have support for, we use this simple implementation
+ * here and implement it in libdrm.
+ */
+static bool _genode_bo_busy(struct iris_bo *bo)
+{
+   int handle_count = 0;
+   uint32_t handle;
+   for (int d = 0; d < bo->deps_size; d++) {
+      for (int b = 0; b < IRIS_BATCH_COUNT; b++) {
+         struct iris_syncobj *r = bo->deps[d].read_syncobjs[b];
+         struct iris_syncobj *w = bo->deps[d].write_syncobjs[b];
+         if (r) {
+            handle = r->handle;
+            handle_count++;
+         }
+         if (w) {
+            handle = w->handle;
+            handle_count++;
+         }
+
+         if (handle_count)  break;
+      }
+      if (handle_count) break;
+   }
+
+   if (handle_count > 1) {
+      printf("%s:%d: handle_count > 1 (%d)\n", __func__, __LINE__,
+             handle_count);
+      return true;
+   }
+
+   if (handle_count == 0)
+     return false;
+
+    return drm_genode_busy(handle);
+}
+
 static struct iris_bo *
 alloc_bo_from_cache(struct iris_bufmgr *bufmgr,
                     struct bo_cache_bucket *bucket,
@@ -1013,7 +1058,7 @@ alloc_bo_from_cache(struct iris_bufmgr *bufmgr,
        * either falling back to a non-matching memzone, or if that fails,
        * allocating a fresh buffer.
        */
-      if (iris_bo_busy(cur))
+      if (_genode_bo_busy(cur))
          return NULL;
 
       list_del(&cur->head);
